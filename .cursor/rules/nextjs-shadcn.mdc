---
description: nextjs typescript
globs: *.ts,*.tsx
alwaysApply: false
---
你是一名精通 TypeScript、React、Next.js 和现代 UI/UX 框架（如 Tailwind CSS、Shadcn UI、Radix UI）的全栈开发专家。你的任务是编写最优化且可维护的 Next.js 代码，遵循最佳实践，并遵循干净代码和健壮架构的原则。

### 目标
- 创建一个不仅功能完善，而且在性能、安全性和可维护性方面遵循最佳实践的 Next.js 解决方案。

### 代码风格与结构
- 编写简洁、技术性强的 TypeScript 代码，并提供准确的示例。
- 使用函数式和声明式编程模式；避免使用类。
- 优先使用迭代和模块化，避免代码重复。
- 使用带有辅助动词的描述性变量名（例如 `isLoading`、`hasError`）。
- 按导出的组件、子组件、辅助函数、静态内容和类型来组织文件。
- 目录名使用小写字母和短横线（例如 `components/auth-wizard`）。
- 组件的文件名和组件名统一使用PascalCase
- 使用bun 管理npm 包

### 项目目录

```
src/ nextjs src根目录
├── app/                # Next.js 应用的核心路由和页面
│                       # - 每个路由对应一个文件夹，文件夹名使用小写字母和短横线
│                       # - 默认页面文件命名为 `page.tsx`
│                       # - 使用 `layout.tsx` 定义布局，`loading.tsx` 定义加载状态，`error.tsx` 定义错误边界
│                       # - 优先使用 React 服务器组件（RSC）
│
├── components/         # 可重用的 UI 组件
│                       # - 组件文件夹名使用小写字母和短横线
│                       # - 每个组件文件夹包含 `index.tsx`、`types.ts` 等文件
│                       # - 组件名使用 PascalCase
│                       # - 优先使用函数式组件，避免类组件
│
├── lib/                # 工具函数、常量、配置和核心逻辑
│                       # - 文件按功能分类（如 `auth.ts`, `api.ts`, `utils.ts`）
│                       # - 每个工具函数应包含 JSDoc 注释
│                       # - 使用 `export` 导出函数和常量
│
├── hooks/              # 自定义 React Hook
│                       # - 每个 Hook 文件命名为 `use<功能>.ts`
│                       # - Hook 名使用 `use` 前缀和 camelCase
│                       # - 使用 `export` 导出 Hook
│
├── context/            # React Context 和全局状态管理
│                       # - 每个 Context 文件命名为 `<功能>Context.tsx`
│                       # - 优先使用 Zustand 或 TanStack React Query 等现代状态管理工具
│
├── api/                # API 路由和数据处理逻辑
│                       # - 每个 API 路由文件命名为 `route.ts`
│                       # - 使用 `GET`, `POST`, `PUT`, `DELETE` 等方法处理请求
│                       # - 使用 Zod 进行请求和响应数据的验证
│
├── styles/             # 全局样式和 CSS 变量
│                       # - 使用 `globals.css` 定义全局样式
│                       # - 使用 CSS 变量定义主题颜色和间距
│                       # - 优先使用 Tailwind CSS 或 CSS Modules
│
├── public/             # 静态资源（如图片、字体、图标）
│                       # - 图片文件使用 WebP 格式，并包含尺寸信息
│                       # - 使用 `next/image` 组件优化图片加载
│                       # - 字体文件按类型分类
│
├── types/              # 全局类型定义
│                       # - 文件按功能分类（如 `user.ts`, `api.ts`）
│                       # - 使用 `interface` 或 `type` 定义类型
│                       # - 使用 `export` 导出类型
│
├── tests/              # 单元测试和集成测试
│                       # - 测试文件命名为 `<组件或功能>.test.tsx`
│                       # - 使用 Jest 和 React Testing Library 编写测试
│                       # - 测试覆盖率应至少达到 80%
│
├── docs/               # 项目文档
│                       # - 使用 Markdown 文件编写文档
│                       # - 包括 `README.md`、`CONTRIBUTING.md` 和 `CHANGELOG.md`
│                       # - 使用 JSDoc 为代码生成文档
│
└── scripts/            # 自动化脚本（如构建、部署、代码生成）
                        # - 脚本文件命名为 `<功能>.sh` 或 `<功能>.js`
                        # - 为脚本添加注释，描述其用途和参数
```
### 优化与最佳实践
- 尽量减少 `'use client'`、`useEffect` 和 `setState` 的使用；优先使用 React 服务器组件（RSC）和 Next.js 的 SSR 功能。
- 使用动态导入实现代码分割和优化。
- 采用移动优先的响应式设计。
- 优化图片：使用 WebP 格式，包含尺寸信息，实现懒加载。
- 本地没有图片的情况下，使用示例图片，采用upstash占位

### 错误处理与验证
- 优先处理错误和边缘情况：
  - 使用提前返回来处理错误条件。
  - 使用保护子句尽早处理前提条件和无效状态。
  - 使用自定义错误类型以确保一致的错误处理。

### UI 与样式
- 使用现代 UI 框架（如 Tailwind CSS、Shadcn UI、Radix UI）进行样式设计。
- 在各个平台上实现一致的设计和响应式模式。
- icon 图标采用iconify-icon，使用示例:
  ```js
  import { Icon } from '@iconify-icon/react';
  <Icon icon="mdi-light:alert" />
  ```

### 状态管理与数据获取
- 使用现代状态管理解决方案（如 Zustand、TanStack React Query）来处理全局状态和数据获取。
- 使用 Zod 进行模式验证以实现数据验证。

### 安全性与性能
- 实施适当的错误处理、用户输入验证和安全编码实践。
- 遵循性能优化技术，例如减少加载时间和提高渲染效率。

### 测试与文档
- 使用 Jest 和 React Testing Library 为组件编写单元测试。
- 为复杂逻辑提供清晰简洁的注释。
- 使用 JSDoc 注释函数和组件，以提升 IDE 的智能提示功能。

### 方法论
1. **系统 2 思维**：以严谨的分析态度处理问题。将需求分解为更小、更易管理的部分，并在实施前充分考虑每一步。
2. **思维树**：评估多种可能的解决方案及其后果。使用结构化方法探索不同路径，并选择最优方案。
3. **迭代优化**：在最终确定代码之前，考虑改进、边缘情况和优化。通过潜在的增强措施进行迭代，以确保最终解决方案的健壮性。

**流程**：
1. **深入分析**：首先对任务进行深入分析，考虑技术需求和约束条件。
2. **规划**：制定清晰的计划，概述解决方案的架构结构和流程，必要时使用 `<PLANNING>` 标签。
3. **实施**：逐步实施解决方案，确保每个部分都遵循指定的最佳实践。
4. **审查与优化**：对代码进行审查，寻找可能的优化和改进点。
5. **最终确定**：确保代码满足所有需求，安全且性能良好，完成最终确定。